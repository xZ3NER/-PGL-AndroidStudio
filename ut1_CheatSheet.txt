*VER FUNCIÓN DEL CÓDIGO COMENTADO -> IR A LA CARPETA CUYO NOMBRE SEA '[NOMBRE]'

*1.-[FirstApp]=================================================================================================================\\

1.a.- Buscar componente por ID (forma 1)
Acceder a su texto -> al final '.text', funciona como getter y setter (get -> .toString())

->  findViewById<TextView>(R.id.textViewSubString)

*2.-[ViewBinding_ACT4]=========================================================================================================\\

2.a.- Buscar componente por ID (forma 2)
Añadir en 'build.gradle' -> android{ 'aquí' } -> viewBinding{ enabled = true }

->  private lateinit var viewBinding: ActivityMainBinding (fuera de onCreate())
->  viewBinding = ActivityMainBinding.inflate(layoutInflater) (dentro de onCreate())
->  setContentView(viewBinding.root)
->  val componente = viewBinding.idDelComponente

2.b.- String-array en strings.xml para Spinners

->  <string-array name="nombre"><item>dato</item><item>...</item></string-array>

2.c.- Cargar string-array desde strings.xml al spinner mediante código
Opción gráfico: Spinner -> Common Attributes -> Entries -> @array/nombreDelString-array

->  val arrayAdap = ArrayAdapter.createFromResource(this,R.array.nombreDelString-array,
            com.google.android.material.R.layout.support_simple_spinner_dropdown_item)
->  arrayAdap.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
->  idSpinner.adapter = arrayAdap

*3.-[ZonaEstadio_ACT3]=========================================================================================================\\

3.a.- Alertas (getText funciona con HTML, getString NO)

->  val alert = AlertDialog.Builder(this).create()
->  alert.setMessage(getText(R.string.etiquetaDelStringsXML)).show()

*4.-[LoginApp]=================================================================================================================\\

4.a.- Mensaje Toast

->  Toast.makeText(this,"Mensaje a mostrar",Toast.LENGTH_LONG).show()

4.b.- Usar permisos
//Añadir en AndroidManifest.xml: (name="tipo de permiso")

->  <uses-permission android:name="android.permission.CAMERA"/>

4.c.- Verifica los permisos (boolean)
En MainActivity u otra clase (permission.tipo de permiso)
this||applicationContext||activity

->  ActivityCompat.checkSelfPermission(this,android.Manifest.permission.CAMERA)==PackageManager.PERMISSION_GRANTED

4.d.- Solicita permisos
En MainActivity u otra clase (permission.tipo de permiso)

->  ActivityCompat.requestPermissions(this, arrayOf(android.Manifest.permission.CAMERA),1)

4.e.- Pasar de una Activity a otra + pasar datos a otra Activity
(this@activityActual, otraActivity::class.java)

->  val intent = Intent(this@MainActivity, Welcome::class.java)
->  intent.putExtra("key", datoAPasar)
->  startActivity(intent)

4.f.- Obtener datos en una Activity pasados desde otra

->  val bundle = intent.extras
->  val datoPasado:String? = bundle?.getString("key")

4.g.- Salir del Activity

->  finish()

*5.-[Fragments]================================================================================================================\\

5.a.- Crear instancia de nuestro Fragment + pasarle argumentos

->  val frag = NombreDeNuestraClaseFragment()
->  val datosAPasar = Bundle()
->  datosAPasar.putString("key", dato) (Bundle trabaja con HashMaps)
->  frag.arguments = datosAPasar

5.b.- Cambiar el Fragment visible del FrameLayout (los fragments van dentro de frameLayouts)

->  val fragment = supportFragmentManager.beginTransaction()
->  fragment.replace(R.id.NombreDelFrameLayout, frag) (val frag en 5.a.-)
->  fragment.commit()

5.c.- Usar los argumentos que se pasaron del Activity al Fragment
Cambiar -> Arriba del todo -> private const val ARG_PARAM... = "key"
Cambiar -> Poco más abajo -> private var nombreDato: String? = null
Cambiar -> OnCreate() -> nombreDato = it.getString(ARG_PARAM...)
(onViewCreated() = ejecuta su contenido una vez el onCreatedView() esté creado,para evitar errores)

-> view.findViewById<Tipo>(R.id.IdComponente).text = nombreDato

5.d.- Usar findViewById en Fragments
(onCreateView() = usar solo para crear la vista, .findViewById usar en onViewCreated())

->  val fragView = inflater.inflate(R.layout.IdDelFragmento, container, false)
->  fragView.findViewById<>()

*6.-[RecyclerView]=============================================================================================================\\

ESTRUCTURA DEL RECYCLER VIEW *(: = hereda de...)
MainActivity.kt -> Componente RecyclerView -> Clase adapter: RecyclerView.Adapter<'ViewHolder'>() ->
-> Clase viewHolder: RecyclerView.ViewHolder('View') -> View = cada item del Recycler, que se contruye con ->
-> listitem_nombre.xml -> Clase adapter -> (override) onCreateViewHolder():'ViewHolder' -> Crea item (View) -> 
-> (override) onBindViewHolder() -> Llama a método 'bind' de nuestro 'ViewHolder' -> bind() asigna valores a ->
-> los componentes de la vista listitem_nombre.xml con los datos del data class -> MainActivity.kt crea array ->
-> de objetos -> Crea instancia de Clase Adapter -> Asigna layout a componente Recycler -> Asigna nuestra clase -> 
-> Adapter a nuestro Recycler.

Pasos para implementar un RecyclerView:

6.1.- Añadir en 'build.gradle' -> implementation 'androidx.recyclerview:recyclerview:1.2.1'

6.2.- Añadir en el componente en algun .xml -> <androidx.recyclerview.widget.RecyclerView .../>

6.3.- Crear un fichero listitem_'nombre'.xml en 'res/layout' que definirá el View de cada item dentro
	de nuestro RecyclerView.

6.4.- Creamos una data class con los posibles datos de cada uno de nuestros items.
-> data class Nombre(val dato1: Tipo, val dato2: Tipo...)

6.5.- Creamos nuestra clase ViewHolder que hereda de Recycler.ViewHolder() y que contiene una funcion bind().
-> class nombreViewHolder(val item: View): RecyclerView.ViewHolder(item) {
	fun bindDataClass(dataClass: DataClass) {
		'Asignar valores como: texto, a los componentes mediante los id de item -> item.findViewById...'
	}
}

6.6.- Creamos nuestra clase Adapter, que hereda de Recycler.Adapter<NuestroViewHolder>(), contiene 3 funciones override.
-> class nombreAdapter(private val datos: Array<DataClass>, private val clickListener: (DataClass) -> Unit): 
RecyclerView.Adapter<NuestroViewHolder>() [clickListener no es obligatorio]

IMPLEMENTAMOS LAS FUNCIONES OVERRIDE

6.7- Implementamos fun -> onCreateViewHolder [Construye un View llamado item a partir de nuestro .xml]
-> override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): NuestroViewHolder {
        val item = LayoutInflater.from(parent.context).inflate(R.layout.listitem_nombre,parent,false) as LinearLayout
        return NuestroViewHolder(item)
    }

6.8.- Implementamos fun onBindViewHolder 
[Llama al método bind de nuestro ViewHolder por cada objeto dentro de nuestra lista datos, 
y le pasa el objeto actual de nuestro dataClass, también añade un listener a nuestro item en caso necesario]
-> override fun onBindViewHolder(holder: NuestroViewHolder, position: Int) {
        val dataClass = datos[position]
        holder.bindDataClass(dataClass)

        holder.item.setOnClickListener {clickListener(dataClass)}
    }

6.9.- Implementamos fun getItemCount [Devuelve el tamaño actual de nuestra lista de objetos DataClass]
-> override fun getItemCount(): Int = datos.size

6.10.- MainActivity.kt -> buscamos nuestro componente RecyclerView y creamos un array de nuestro DataClass
-> recyclerView = viewBinding.recyclerView
-> val datos = Array('size') {it -> DataClass('parametros')}

6.11.- Asignamos un layout (el formato que queramos mostrar) a nuestro RecyclerView
-> recyclerView.layoutManager = LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false)

6.12.- Creamos la instancia de nuestra Clase Adapter y se lo asignamos al RecyclerView
-> val adaptador = nombreAdapter(datos) {
           'código a ejecutar del listener'
        }
-> recyclerView.adapter = adaptador

6.13.- En caso de querer decorar nuestros items, usar:
-> recyclerView.addItemDecoration(DividerItemDecoration(this,DividerItemDecoration.VERTICAL))

*7.-[SharedPreferences]=======================================================================================================\\

7.1.- Creamos nuestro SharedPreferences y su editor (almacenar/recuperar preferencias con clave-valor)
-> val sharedPreferences = getSharedPreferences(preferencesName, MODE_PRIVATE)
   val preferencesEditor = sharedPreferences.edit()
   
7.2.- Para guardar preferencias (comprobar antes los EditText, si son null, etc)
-> preferencesEditor.putString(keyEditText.text.toString(),dataEditText.text.toString())
   preferencesEditor.apply() / preferencesEditor.commit()
   
7.3.- Para recuperar preferencias (comprobar antes si no es null)
-> val data = sharedPreferences.getString(keyEditText.text.toString(), "")
   dataTextField.setText(data)

*8.-[Ficheros]=======================================================================================================\\



EXTRA.- Listeners==============================================================================================================\\

->  botones/textView/... = .setOnClickListener {accionARealizar}

->  radioGroup/checkBox/... = .setOnCheckedChangeListener {tipo, selected -> accionARealizar}

->  spinner... = .onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
override fun onItemSelected(p0: AdapterView<*>?, p1: View?, p2: Int, p3: Long) {
//"p0!!.getItemAtPosition(p2)" = devuelve el item seleccionado en String
}
override fun onNothingSelected(p0: AdapterView<*>?){}}





